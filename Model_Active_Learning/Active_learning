from sklearn.ensemble import RandomForestClassifier
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from collections.abc import Sequence
import random


class Active_learning():
    def __init__(self, data_file: str, set_of_labels: Sequence):
        self.data_file = data_file
        self.datapd = self.get_sensor_data(data_file)
        self.model = self.determine_model()
        self.set_of_labels = set_of_labels
        self.labeled_ids = []
        self.unlabeled_ids = set(range(0, self.datapd.shape[0]))
        # self.train_indexes = list(range(10))
        # self.unknown_indexes = list(range(10, len_pool))
        self.X_pool, self.X_test, self.y_pool, self.y_test = self.split_pool_test()
        # self.activities = {}
        self.training()
        
    @property
    def unlabeled_ids(self):
        return set(range(self.datapd.shape[0]).difference(set(self.labeled_ids)))
    
    def determine_model(self):
        """_summary_

        Returns:
            _type_: _description_
        """        
        return RandomForestClassifier(max_depth=9, criterion='gini')
        
    @staticmethod
    def get_sensor_data(data_file: str):
        """_summary_

        Args:
            data_file (str): _description_

        Returns:
            _type_: _description_
        """        
        return pd.read_csv(data_file)

    def split_pool_test(self):
        """_summary_

        Returns:
            _type_: _description_
        """        
        random_state = 42
        test_size = 0.2
        return train_test_split(self.datapd[['ID'] + self.datapd.colums[3:]], self.datapd['label'], test_size=test_size, random_state=random_state)

    def training(self):
        """_summary_
        """        
        self.set_starting_points()
        self.iterate()

    def set_starting_points(self):
        """_summary_
        """        
        '''Generates training set by selecting random starting points, labeling them, and checking if there's an instance of every activity'''
        seen_activities = [] # list of strings
        range_var = 4 * len(self.set_of_labels)
        # generate random points
        for i in range(range_var):
            # pick a random point from X_pool
            while True:
                random_id = random.randint(0, self.datapd.shape[0])
                if random_id not in self.labeled_ids:
                    break
            self.labeled_ids.append(random_id)
            got_labeled = self.identify(self.datapd.iloc[random_id]['time'])
            if got_labeled not in self.set_of_labels:
                self.set_of_labels.add(got_labeled)
            seen_activities.append(got_labeled)
        # keep adding points until every activity is in the training set
        while not len(set(seen_activities)) == len(self.set_of_labels):
            while True:
                random_id = random.randint(0, self.datapd.shape[0])
                if random_id not in self.labeled_ids:
                    break
            self.labeled_ids.append(random_id)
            got_labeled = self.identify(random_id)
            if got_labeled not in self.set_of_labels:
                self.set_of_labels.add(got_labeled)
            seen_activities.append(got_labeled)

        # Randomized phase is done
        # Give labels to the ID's in the pandaset
        for i in range(self.labeled_ids):
            self.datapd.iloc[self.labeled_ids[i]]['label'] = seen_activities[i]

    def set_ambiguous_point(self) -> int:
        """Lets designer label ambiguous point

        Returns:
            int: ID that has been labeled
        """                
        get_id_to_label = self.find_most_ambiguous_id()
        self.labeled_ids.append(get_id_to_label)
        self.datapd.iloc[get_id_to_label]['label'] = self.identify(self.datapd.iloc[get_id_to_label]['time'])
        return get_id_to_label

    def label_test_set(self):
        pass
        # predict y_test
        # let user confirm or correct 

    def identify(self, id):
        return '4'


    # def define_activities(self):
    #     activity_list = []
    #     ask_activity = input("Please input expected activities. Type X when you're done. ")
    #     while ask_activity != "X":
    #         activity_list.append(ask_activity)
    #         ask_activity = input()
    #     for i in range(len(activity_list)):
    #         self.activities[activity_list[i]] = i + 1
    #     print(f"These are your activities: {activity_list}. If you want to make any changes, run this cell again. ")
        # done = input("Type Y if you're done, or N if you want to add more activities. ")
        # if done == "N":
            # ask_activity = input() 
        # return self.activities

    def find_most_ambiguous_id(self):
        '''Finds the most ambiguous sample. The unlabeled sample with the greatest
            difference between most and second most probably classes is the most ambiguous.
            Returns only the id of this sample'''
        preds = self.model.predict_proba(self.X_pool.iloc[self.unlabeled_ids])
        sorted_preds = np.sort(preds, axis=1)
        lowest_margin = 1
        lowest_margin_sample_id = None
        for unknown_sample in self.X_pool.iloc[self.unlabeled_ids]:
            # idk of unknown_sample['ID'] werkt:
            margin = sorted_preds[unknown_sample['ID'], -1] - sorted_preds[unknown_sample['ID'], -2]
            if margin < lowest_margin:
                lowest_margin_sample_id = unknown_sample['ID']
        # most_ambiguous = X_pool.iloc[lowest_margin_sample_id]
        return lowest_margin_sample_id

    def iteration_0(self):
        X_train = X_pool.iloc[self.labeled_ids]
        y_train = y_pool.iloc[self.labeled_ids]
        self.model.fit(X_train, y_train)
        self.plot_model('Iteration 0')
    
    def iterate(self, max_iter):
        max_iter_reached = False
        stop_iterating = False
        iter_num = 0
        while not max_iter_reached or stop_iterating:
            iter_num += 1
            # find most ambiguous point (find_most_ambiguous_id)
            # label it (set_ambiguous_point)
            # add to training data 
            new_index = self.set_ambiguous_point()
            # retrain
            ... 
            # show designer plot and performance: ask if they want to stop, continue, or retrain on new samples
            self.plot_model(f'Iteration {num_iter}', new_index = new_index)
            question = input("Examine the plot. Enter C if you want to continue, R if your performance is not improving, or S if you are satisfied with this models' performance")
            if question == 'C':
                ...
            elif question == 'R':
                ...
            elif question == 'S':
                ...
            else:
                print('Invalid input')

    def evaluate_model(self):
        """_summary_
        """        
        '''This function gives possibly relevant evaluation metrics like accuracy, precision, recall and F1 score.'''
        y_pred = self.model.predict(self.X_test)
        y_true = self.y_test
        test_acc = accuracy_score(y_test, y_pred)
        print("Test Accuracy : ", test_acc)
        print("MCC Score : ", matthews_corrcoef(y_true, y_pred))
        print("Classification Report : ")
        print(classification_report(self.y_test, y_pred))

    def plot_model(self, title: str, new_index: bool = False):
        """_summary_

        Args:
            title (str): _description_
            new_index (bool, optional): _description_. Defaults to False.
        """        
        '''Makes a plot. Black points are unlabeled, red points are labeled, star is the most ambiguous point in that iteration.'''
        xlabel = 'Dimension 1'
        ylabel = 'Dimension 2'
        # define data variables
        self.X_train = self.X_pool.iloc[self.labeled_ids]
        self.y_train = self.y_pool.iloc[self.labeled_ids]
        self.X_unk = self.X_pool.iloc[self.unlabeled_ids]
        if new_index:
            X_new = self.X_pool.iloc[new_index]
        # plot points
        plt.scatter(X_unk, c='k', marker = '.')
        plt.scatter(X_train, y_train, c='r', marker = 'o')
        if new_index:
            plt.scatter(X_new, c='y', marker="*", s=125)
        # axis and title name
        plt.xlabel(xlabel)
        plt.ylabel(ylabel)
        plt.title(title)
        plt.show()
